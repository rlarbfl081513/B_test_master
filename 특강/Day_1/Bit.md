# 📘 비트 연산자(Bitwise Operators) 쉽게 이해하기

## 📌 비트란?

컴퓨터는 모든 데이터를 **0과 1**로 표현함.

* 이 0 또는 1 하나를 **비트(bit)** 라고 함
* 여러 비트가 모이면 바이트(byte), 킬로바이트(KB) 등으로 확장됨

```
1 bit  = 0 또는 1
8 bits = 1 byte
```

---

## ✅ 비트 연산자란?

숫자를 **2진수(bit)** 형태로 바꾼 후, **비트 단위로 계산하는 연산자**

예: `a = 10`, `b = 4`

```
a = 0b1010  # 10
b = 0b0100  # 4
```

> 여기서 `0b`는 "이 숫자가 2진수(binary)임"을 나타내는 **접두사**야.
> 즉, `0b1010`은 2진수 1010이라는 뜻이고, 10진수로는 10이야.

---

## 🔢 숫자를 비트로 표현하는 방법

십진수(Decimal)를 이진수(Binary)로 바꾸려면, 2로 나누는 방법을 반복하면 돼.

예: 13을 2진수로 나타내기

```
13 ÷ 2 = 6 ... 1
6 ÷ 2 = 3 ... 0
3 ÷ 2 = 1 ... 1
1 ÷ 2 = 0 ... 1
→ 아래에서 위로 읽으면: 1101
따라서 13 = 0b1101
```

또는 Python에서 이렇게 쓸 수 있음:

```python
bin(13)  # 결과: '0b1101'
```

---

## 🔧 주요 비트 연산자 6가지 요약

| 기호   | 이름      | 예시                   | 설명               |               |            |
| ---- | ------- | -------------------- | ---------------- | ------------- | ---------- |
| `&`  | AND     | `1010 & 0100 = 0000` | 둘 다 1일 때만 1      |               |            |
| \`   | \`      | OR                   | \`1010           | 0100 = 1110\` | 하나라도 1이면 1 |
| `^`  | XOR     | `1010 ^ 0100 = 1110` | 다르면 1, 같으면 0     |               |            |
| `~`  | NOT     | `~1010 = 0101` (반전)  | 0 → 1, 1 → 0     |               |            |
| `<<` | 왼쪽 쉬프트  | `1010 << 1 = 10100`  | 왼쪽으로 밀기 (2배 증가)  |               |            |
| `>>` | 오른쪽 쉬프트 | `1010 >> 1 = 0101`   | 오른쪽으로 밀기 (2로 나눔) |               |            |

---

## 🎯 그림으로 이해하기: `a = 0b1010`, `b = 0b0100`

### ① `&` (AND: 둘 다 1일 때만 1)

```
   a: 1 0 1 0
&  b: 0 1 0 0
-------------
     0 0 0 0   → 0 (십진수)
```

### ② `|` (OR: 하나라도 1이면 1)

```
   a: 1 0 1 0
|  b: 0 1 0 0
-------------
     1 1 1 0   → 14 (십진수)
```

### ③ `^` (XOR: 다르면 1, 같으면 0)

```
   a: 1 0 1 0
^  b: 0 1 0 0
-------------
     1 1 1 0   → 14 (십진수)
```

### ④ `~` (NOT: 반전)

NOT 연산자는 모든 비트를 반전시켜 (0은 1로, 1은 0으로) **보수를 만듦**. 파이썬에서는 **2의 보수 표현**을 사용해 음수로 나옴.

```
  a:  0b00001010 (10)
~a:   0b11110101 → -11 (파이썬에서는 -a - 1 이 됨)
```

> 🔍 왜 반전하면 음수가 될까?
> 사람은 -11을 그냥 `-1011`처럼 쓰지만, 컴퓨터는 부호와 절대값을 따로 저장하지 않고 **2의 보수** 방식으로 음수를 표현함. 예를 들어 8비트에서 `11110101`은 다음 과정을 거쳐 -11이 됨:
>
> 1. 맨 앞 비트(1)는 부호 비트 → 음수라는 뜻
> 2. 나머지 비트를 다시 반전하고 +1 하면: `00001011` + 1 = `00001100` (12)
> 3. 따라서 원래 값은 -12 (즉, \~10 = -11)

### ⑤ `<<` (왼쪽 쉬프트: 곱셈 효과)

비트를 왼쪽으로 n칸 이동시키면, **2의 n제곱을 곱한 것과 같음**

* 각 비트가 왼쪽으로 이동하고, **오른쪽에 생긴 빈 자리는 0으로 채움**

```
  a = 0b00001010 = 10
  a << 1 → 0b00010100 = 20 (10 × 2)
  a << 2 → 0b00101000 = 40 (10 × 4)
```

### ⑥ `>>` (오른쪽 쉬프트: 나눗셈 효과)

비트를 오른쪽으로 n칸 이동시키면, **2의 n제곱으로 나눈 몫과 같음**

* 각 비트가 오른쪽으로 이동하고, **왼쪽에 생긴 빈 자리는 0으로 채움** (양수일 경우)

```
  a = 0b00001010 = 10
  a >> 1 → 0b00000101 = 5 (10 // 2)
  a >> 2 → 0b00000010 = 2 (10 // 4)
```

---

## 💡 비트 연산 요약 정리표

| 연산   | 의미           | 결과 조건            |   |       |
| ---- | ------------ | ---------------- | - | ----- |
| `&`  | 둘 다 1이면 1    | 1 & 1 → 1        |   |       |
| \`   | \`           | 하나라도 1이면 1       | 1 | 0 → 1 |
| `^`  | 다르면 1 (XOR)  | 1 ^ 0 → 1        |   |       |
| `~`  | 반전           | \~a = -a - 1     |   |       |
| `<<` | 왼쪽 이동 (곱셈)   | a << n = a × 2ⁿ  |   |       |
| `>>` | 오른쪽 이동 (나눗셈) | a >> n = a // 2ⁿ |   |       |

---

## 🧠 언제 사용하나?

* 특정 **비트를 켜거나 끌 때** (마스킹)
* 짝수/홀수 판별: `x & 1`
* 최적화된 연산 (빠름!)
* 해시 함수, 압축, 암호화, 그래픽 처리 등

---

## ✅ 연습 팁

* 손으로 2진수 직접 써보기!
* 예: `0b0110`과 `0b0101`으로 AND/OR/XOR 해보기
* `~`, `<<`, `>>` 도 계산 연습해보기

---