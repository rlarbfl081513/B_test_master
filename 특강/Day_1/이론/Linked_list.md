# 📚 Linked List vs Array List (파이썬 리스트 등) 비교 정리

## 🔍 개요

* **Linked List**: 노드들이 포인터로 연결된 구조
* **Array List** (예: Python의 list): 연속된 메모리 공간에 데이터를 저장하는 구조

---

## ✅ 삽입 / 삭제 / 접근 비교

| 연산 유형     | Array List (`list`) | Linked List |
| --------- | ------------------- | ----------- |
| 맨 앞 삽입/삭제 | O(N)                | O(1)        |
| 맨 뒤 삽입/삭제 | O(1) (가변 배열)        | O(1)\*      |
| 중간 삽입/삭제  | O(N)                | O(N)        |
| 특정 인덱스 접근 | O(1)                | O(N)        |

> `*` 단, tail 포인터가 있는 경우에 한해 O(1), 없으면 O(N)

---

## ⚙️ 내부 동작 방식

### 📦 Array List (배열 기반)

* 연속된 메모리 공간에 저장
* 중간에 삽입/삭제 시, 나머지 요소를 밀거나 당겨야 함
* **접근 속도가 빠름 (O(1))**

### 🔗 Linked List

* 각 노드가 데이터 + 다음 노드 주소를 저장
* 삽입/삭제는 연결만 바꾸면 되므로 **유연함**
* **접근은 느림 (O(N))**: 처음부터 차례로 찾아야 함

#### ❓ 왜 접근이 느릴까?

* 배열은 메모리상 **연속된 위치**에 저장되어 있어 `index`로 즉시 접근 가능
* 링크드 리스트는 각 노드가 **흩어져 저장**되며, `n번째 노드`를 찾으려면 **앞에서부터 하나씩 따라가야 함**
* 즉, 링크드 리스트는 \*\*직접 접근(random access)\*\*이 불가능하고, \*\*순차 접근(sequential access)\*\*만 가능함

```
배열:        [A][B][C][D] → 바로 A[2] 접근 가능 (O(1))
링크드리스트: A → B → C → D → E → ...
                       ↑
                     C에 도달하려면 순차 탐색 필요 (O(N))
```

---

## 📌 링크드 리스트에서 연결(삽입/삭제)의 시간복잡도는?

### ✅ 1. 맨 앞에 삽입 / 삭제 → O(1)

연결만 바꾸면 되므로 시간복잡도는 상수 시간

```
[head] → A → B → C
삽입: new → A → B → C    (O(1))
삭제:        B → C       (O(1))
```

### ❗ 2. 맨 뒤에 삽입 → O(1) (단, tail 포인터가 있을 경우)

* tail 포인터가 있으면 바로 연결 가능 → O(1)
* 없으면 마지막 노드까지 가야 하므로 → O(N)

### ❗ 3. 중간에 삽입 / 삭제 → O(N)

* 삽입할 위치를 찾기 위한 순회가 필요
* 노드 자체 연결은 O(1)이지만, 위치 탐색 때문에 전체 시간은 O(N)

```
[head] → A → B → C → D
       삽입 위치 찾기 = O(N)
       연결 자체 = O(1)
```

---

## 📌 배열 리스트(Array List)에서 연결(삽입/삭제)의 시간복잡도는?

### ❗ 1. 맨 앞 삽입 / 삭제 → O(N)

* 맨 앞에 삽입하면 모든 요소를 한 칸씩 뒤로 밀어야 함
* 삭제 시에는 앞으로 당겨야 함

```
[0] A B C D
삽입 시 → X A B C D (모두 이동)
삭제 시 →   B C D   (모두 이동)
```

### ✅ 2. 맨 뒤 삽입 / 삭제 → 평균적으로 O(1)

* 파이썬 list는 동적 배열이라 공간이 충분하면 O(1)
* 가득 찼을 경우 새로운 공간으로 복사 → O(N) → **분할상환으로 O(1)**

### ❗ 3. 중간 삽입 / 삭제 → O(N)

* 중간 삽입 시 뒤의 요소들을 한 칸씩 밀어야 함
* 삭제 시에도 당겨야 함

```
[0] A B C D
중간 삽입 → A B X C D (C, D 이동)
중간 삭제 → A   C D   (C, D 이동)
```

---

## 🔄 사용 예시

| 상황            | 추천 자료구조                |
| ------------- | ---------------------- |
| 삽입/삭제가 빈번함    | Linked List            |
| 인덱스를 자주 접근함   | Array List             |
| 메모리 낭비가 중요함   | Linked List (단일 노드 단위) |
| 공간 효율보다 속도 중시 | Array List             |

---

## 🧠 추가 팁

* Python의 `list`는 실제로 **동적 배열 (Dynamic Array)** 형태다.
* Python에는 내장 Linked List는 없고, `collections.deque`를 쓰면 양방향 연결 리스트와 유사한 연산이 가능하다.

---

## ✅ 결론

* 단순 데이터 접근 → `Array List`
* 삽입/삭제 중심 → `Linked List`
* 언제 어디에 삽입/삭제하는지가 시간복잡도를 결정한다!
* 배열은 **빠른 접근**이 가능하고, 링크드 리스트는 **빠른 삽입/삭제**가 가능하다.

---
[정리]
- 링크드리스트는 배열을 표현하는 방식중 하나
- 정적할당을 자주 쓸것임