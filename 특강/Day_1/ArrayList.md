# 분할상환 분석 (Amortized Analysis) - `push_back` 예제

## 0. 분할상환의 정의

* \*\*분할상환 (Amortized Analysis)\*\*는 여러 연산의 총 비용을 구한 뒤, 이를 바탕으로 평균적인 연산 하나의 비용을 계산하는 기법이다.
* 개별 연산의 시간 복잡도는 클 수 있지만, 여러 연산을 종합적으로 보면 전체 비용이 제한되기 때문에 연산당 평균 비용은 작아질 수 있다.

---

## 1. 문제 상황

* **초기 리스트(배열)의 크기**: 10
* 리스트가 가득 차면, **기존 데이터를 전부 복사하여 2배 크기로 확장**함
* 요소를 `push_back` 할 때마다 리스트에 추가됨
* 이 과정에서 간헐적으로 큰 복사 비용이 발생함

---

## 2. 동작 방식 시간 흐름 예시 (예제: 최대 81개 원소)

### 배열 크기 확장 과정

```
배열 용량: 5 + 10 → 20 → 40 → 80 → 160 ...
```

```
[1~5]   → 단순 추가 (O(1)씩)
[6]     → 배열 크기 5 → 10 확장 + 복사 5회 (O(5))

[6~10]   → 단순 추가 (O(1)씩)

[11]     → 배열 크기 10 → 20 확장 + 복사 10회 (O(10))
[12~20]  → 단순 추가 (O(1)씩)

[21]     → 배열 크기 20 → 40 확장 + 복사 20회 (O(20))
[22~40]  → 단순 추가

[41]     → 배열 크기 40 → 80 확장 + 복사 40회 (O(40))
[42~80]  → 단순 추가

[81]     → 배열 크기 80 → 160 확장 + 복사 80회 (O(80))
```

---

## 3. 전체 연산 수 계산

총 `push_back` 81번에 대해 실제 연산 수:

* 단순 추가: 81번

* 복사 연산: 5 + 10 + 20 + 40 + 80 = 155번

* → **총 연산 수 = 81 + 5 + 10 + 20 + 40 + 80 = 236**

* 여기서 중요한 점은:
  * 81 + ( 5 + 10 + 20 + 40 ) + 80 = N + N + N = 3N이라 보면, 3*N보다는 작음
  * 복사 비용은 삽입 횟수가 늘어남에 따라 **기하급수적으로 증가**하지만
  * 그 전체 합은 항상 마지막 복사 횟수(즉, 최댓값 N)에 비례함
  * 즉, 전체 연산 수는 **3N보다 작음** → N이 81일 때 총 연산 수 236은 3×81 = 243보다 작음

---

## 4. 분석: Amortized Analysis

* 총 연산 수 236은 N = 81에 대해:

  $\frac{236}{81} \approx 2.91$

* 결국 전체 연산 수는 O(N)에 비례하며,

* 각 연산의 평균 시간 복잡도는 \*\*Amortized O(1)\*\*로 볼 수 있음

---

## 5. 시간 복잡도 정리

| 상황      | 시간 복잡도         | 설명                             |
| ------- | -------------- | ------------------------------ |
| 단순 push | O(1)           | 배열 공간이 남아있을 경우                 |
| 확장 발생   | O(N)           | 복사 연산이 발생할 경우                  |
| 평균      | Amortized O(1) | 전체 N개 연산의 총합이 O(N)이므로 평균은 O(1) |

---

## 6. 시간 복잡도 표기의 특징

* `push_back`의 시간 복잡도는:

  * **O(1)**: 일반적인 상황에서의 설명
  * **O(N)**: 최악의 경우 또는 총합 관점에서의 설명
  * 더 정확한 표기는 \*\*O(N)\*\*이지만,
  * 분할상환 관점에서는 평균적으로 각 연산이 \*\*O(1)\*\*과 같다고 볼 수 있음

---
